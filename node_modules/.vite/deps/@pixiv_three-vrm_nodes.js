import "./chunk-5FLJOSHH.js";
import {
  LightingModel,
  NodeMaterial,
  PropertyNode,
  TSL,
  TempNode
} from "./chunk-J65SOX3F.js";
import {
  Color,
  NormalBlending,
  REVISION,
  Vector2
} from "./chunk-5F7CNAW3.js";

// node_modules/three/build/three.tsl.js
var BRDF_GGX = TSL.BRDF_GGX;
var BRDF_Lambert = TSL.BRDF_Lambert;
var BasicShadowFilter = TSL.BasicShadowFilter;
var Break = TSL.Break;
var Continue = TSL.Continue;
var DFGApprox = TSL.DFGApprox;
var D_GGX = TSL.D_GGX;
var Discard = TSL.Discard;
var EPSILON = TSL.EPSILON;
var F_Schlick = TSL.F_Schlick;
var Fn = TSL.Fn;
var INFINITY = TSL.INFINITY;
var If = TSL.If;
var Switch = TSL.Switch;
var Loop = TSL.Loop;
var NodeShaderStage = TSL.NodeShaderStage;
var NodeType = TSL.NodeType;
var NodeUpdateType = TSL.NodeUpdateType;
var NodeAccess = TSL.NodeAccess;
var PCFShadowFilter = TSL.PCFShadowFilter;
var PCFSoftShadowFilter = TSL.PCFSoftShadowFilter;
var PI = TSL.PI;
var PI2 = TSL.PI2;
var Return = TSL.Return;
var Schlick_to_F0 = TSL.Schlick_to_F0;
var ScriptableNodeResources = TSL.ScriptableNodeResources;
var ShaderNode = TSL.ShaderNode;
var TBNViewMatrix = TSL.TBNViewMatrix;
var VSMShadowFilter = TSL.VSMShadowFilter;
var V_GGX_SmithCorrelated = TSL.V_GGX_SmithCorrelated;
var abs = TSL.abs;
var acesFilmicToneMapping = TSL.acesFilmicToneMapping;
var acos = TSL.acos;
var add = TSL.add;
var addNodeElement = TSL.addNodeElement;
var agxToneMapping = TSL.agxToneMapping;
var all = TSL.all;
var alphaT = TSL.alphaT;
var and = TSL.and;
var anisotropy = TSL.anisotropy;
var anisotropyB = TSL.anisotropyB;
var anisotropyT = TSL.anisotropyT;
var any = TSL.any;
var append = TSL.append;
var array = TSL.array;
var arrayBuffer = TSL.arrayBuffer;
var asin = TSL.asin;
var assign = TSL.assign;
var atan = TSL.atan;
var atan2 = TSL.atan2;
var atomicAdd = TSL.atomicAdd;
var atomicAnd = TSL.atomicAnd;
var atomicFunc = TSL.atomicFunc;
var atomicMax = TSL.atomicMax;
var atomicMin = TSL.atomicMin;
var atomicOr = TSL.atomicOr;
var atomicStore = TSL.atomicStore;
var atomicSub = TSL.atomicSub;
var atomicXor = TSL.atomicXor;
var atomicLoad = TSL.atomicLoad;
var attenuationColor = TSL.attenuationColor;
var attenuationDistance = TSL.attenuationDistance;
var attribute = TSL.attribute;
var attributeArray = TSL.attributeArray;
var backgroundBlurriness = TSL.backgroundBlurriness;
var backgroundIntensity = TSL.backgroundIntensity;
var backgroundRotation = TSL.backgroundRotation;
var batch = TSL.batch;
var bentNormalView = TSL.bentNormalView;
var billboarding = TSL.billboarding;
var bitAnd = TSL.bitAnd;
var bitNot = TSL.bitNot;
var bitOr = TSL.bitOr;
var bitXor = TSL.bitXor;
var bitangentGeometry = TSL.bitangentGeometry;
var bitangentLocal = TSL.bitangentLocal;
var bitangentView = TSL.bitangentView;
var bitangentWorld = TSL.bitangentWorld;
var bitcast = TSL.bitcast;
var blendBurn = TSL.blendBurn;
var blendColor = TSL.blendColor;
var blendDodge = TSL.blendDodge;
var blendOverlay = TSL.blendOverlay;
var blendScreen = TSL.blendScreen;
var blur = TSL.blur;
var bool = TSL.bool;
var buffer = TSL.buffer;
var bufferAttribute = TSL.bufferAttribute;
var bumpMap = TSL.bumpMap;
var burn = TSL.burn;
var bvec2 = TSL.bvec2;
var bvec3 = TSL.bvec3;
var bvec4 = TSL.bvec4;
var bypass = TSL.bypass;
var cache = TSL.cache;
var call = TSL.call;
var cameraFar = TSL.cameraFar;
var cameraIndex = TSL.cameraIndex;
var cameraNear = TSL.cameraNear;
var cameraNormalMatrix = TSL.cameraNormalMatrix;
var cameraPosition = TSL.cameraPosition;
var cameraProjectionMatrix = TSL.cameraProjectionMatrix;
var cameraProjectionMatrixInverse = TSL.cameraProjectionMatrixInverse;
var cameraViewMatrix = TSL.cameraViewMatrix;
var cameraWorldMatrix = TSL.cameraWorldMatrix;
var cbrt = TSL.cbrt;
var cdl = TSL.cdl;
var ceil = TSL.ceil;
var checker = TSL.checker;
var cineonToneMapping = TSL.cineonToneMapping;
var clamp = TSL.clamp;
var clearcoat = TSL.clearcoat;
var clearcoatRoughness = TSL.clearcoatRoughness;
var code = TSL.code;
var color = TSL.color;
var colorSpaceToWorking = TSL.colorSpaceToWorking;
var colorToDirection = TSL.colorToDirection;
var compute = TSL.compute;
var computeSkinning = TSL.computeSkinning;
var cond = TSL.cond;
var Const = TSL.Const;
var context = TSL.context;
var convert = TSL.convert;
var convertColorSpace = TSL.convertColorSpace;
var convertToTexture = TSL.convertToTexture;
var cos = TSL.cos;
var cross = TSL.cross;
var cubeTexture = TSL.cubeTexture;
var dFdx = TSL.dFdx;
var dFdy = TSL.dFdy;
var dashSize = TSL.dashSize;
var debug = TSL.debug;
var decrement = TSL.decrement;
var decrementBefore = TSL.decrementBefore;
var defaultBuildStages = TSL.defaultBuildStages;
var defaultShaderStages = TSL.defaultShaderStages;
var defined = TSL.defined;
var degrees = TSL.degrees;
var deltaTime = TSL.deltaTime;
var densityFog = TSL.densityFog;
var densityFogFactor = TSL.densityFogFactor;
var depth = TSL.depth;
var depthPass = TSL.depthPass;
var difference = TSL.difference;
var diffuseColor = TSL.diffuseColor;
var directPointLight = TSL.directPointLight;
var directionToColor = TSL.directionToColor;
var dispersion = TSL.dispersion;
var distance = TSL.distance;
var div = TSL.div;
var dodge = TSL.dodge;
var dot = TSL.dot;
var drawIndex = TSL.drawIndex;
var dynamicBufferAttribute = TSL.dynamicBufferAttribute;
var element = TSL.element;
var emissive = TSL.emissive;
var equal = TSL.equal;
var equals = TSL.equals;
var equirectUV = TSL.equirectUV;
var exp = TSL.exp;
var exp2 = TSL.exp2;
var expression = TSL.expression;
var faceDirection = TSL.faceDirection;
var faceForward = TSL.faceForward;
var faceforward = TSL.faceforward;
var float = TSL.float;
var floor = TSL.floor;
var fog = TSL.fog;
var fract = TSL.fract;
var frameGroup = TSL.frameGroup;
var frameId = TSL.frameId;
var frontFacing = TSL.frontFacing;
var fwidth = TSL.fwidth;
var gain = TSL.gain;
var gapSize = TSL.gapSize;
var getConstNodeType = TSL.getConstNodeType;
var getCurrentStack = TSL.getCurrentStack;
var getDirection = TSL.getDirection;
var getDistanceAttenuation = TSL.getDistanceAttenuation;
var getGeometryRoughness = TSL.getGeometryRoughness;
var getNormalFromDepth = TSL.getNormalFromDepth;
var getParallaxCorrectNormal = TSL.getParallaxCorrectNormal;
var getRoughness = TSL.getRoughness;
var getScreenPosition = TSL.getScreenPosition;
var getShIrradianceAt = TSL.getShIrradianceAt;
var getTextureIndex = TSL.getTextureIndex;
var getViewPosition = TSL.getViewPosition;
var getShadowMaterial = TSL.getShadowMaterial;
var getShadowRenderObjectFunction = TSL.getShadowRenderObjectFunction;
var glsl = TSL.glsl;
var glslFn = TSL.glslFn;
var grayscale = TSL.grayscale;
var greaterThan = TSL.greaterThan;
var greaterThanEqual = TSL.greaterThanEqual;
var hash = TSL.hash;
var highpModelNormalViewMatrix = TSL.highpModelNormalViewMatrix;
var highpModelViewMatrix = TSL.highpModelViewMatrix;
var hue = TSL.hue;
var increment = TSL.increment;
var incrementBefore = TSL.incrementBefore;
var instance = TSL.instance;
var instanceIndex = TSL.instanceIndex;
var instancedArray = TSL.instancedArray;
var instancedBufferAttribute = TSL.instancedBufferAttribute;
var instancedDynamicBufferAttribute = TSL.instancedDynamicBufferAttribute;
var instancedMesh = TSL.instancedMesh;
var int = TSL.int;
var inverseSqrt = TSL.inverseSqrt;
var inversesqrt = TSL.inversesqrt;
var invocationLocalIndex = TSL.invocationLocalIndex;
var invocationSubgroupIndex = TSL.invocationSubgroupIndex;
var ior = TSL.ior;
var iridescence = TSL.iridescence;
var iridescenceIOR = TSL.iridescenceIOR;
var iridescenceThickness = TSL.iridescenceThickness;
var ivec2 = TSL.ivec2;
var ivec3 = TSL.ivec3;
var ivec4 = TSL.ivec4;
var js = TSL.js;
var label = TSL.label;
var length = TSL.length;
var lengthSq = TSL.lengthSq;
var lessThan = TSL.lessThan;
var lessThanEqual = TSL.lessThanEqual;
var lightPosition = TSL.lightPosition;
var lightShadowMatrix = TSL.lightShadowMatrix;
var lightTargetDirection = TSL.lightTargetDirection;
var lightTargetPosition = TSL.lightTargetPosition;
var lightViewPosition = TSL.lightViewPosition;
var lightingContext = TSL.lightingContext;
var lights = TSL.lights;
var linearDepth = TSL.linearDepth;
var linearToneMapping = TSL.linearToneMapping;
var localId = TSL.localId;
var globalId = TSL.globalId;
var log = TSL.log;
var log2 = TSL.log2;
var logarithmicDepthToViewZ = TSL.logarithmicDepthToViewZ;
var loop = TSL.loop;
var luminance = TSL.luminance;
var mediumpModelViewMatrix = TSL.mediumpModelViewMatrix;
var mat2 = TSL.mat2;
var mat3 = TSL.mat3;
var mat4 = TSL.mat4;
var matcapUV = TSL.matcapUV;
var materialAO = TSL.materialAO;
var materialAlphaTest = TSL.materialAlphaTest;
var materialAnisotropy = TSL.materialAnisotropy;
var materialAnisotropyVector = TSL.materialAnisotropyVector;
var materialAttenuationColor = TSL.materialAttenuationColor;
var materialAttenuationDistance = TSL.materialAttenuationDistance;
var materialClearcoat = TSL.materialClearcoat;
var materialClearcoatNormal = TSL.materialClearcoatNormal;
var materialClearcoatRoughness = TSL.materialClearcoatRoughness;
var materialColor = TSL.materialColor;
var materialDispersion = TSL.materialDispersion;
var materialEmissive = TSL.materialEmissive;
var materialIOR = TSL.materialIOR;
var materialIridescence = TSL.materialIridescence;
var materialIridescenceIOR = TSL.materialIridescenceIOR;
var materialIridescenceThickness = TSL.materialIridescenceThickness;
var materialLightMap = TSL.materialLightMap;
var materialLineDashOffset = TSL.materialLineDashOffset;
var materialLineDashSize = TSL.materialLineDashSize;
var materialLineGapSize = TSL.materialLineGapSize;
var materialLineScale = TSL.materialLineScale;
var materialLineWidth = TSL.materialLineWidth;
var materialMetalness = TSL.materialMetalness;
var materialNormal = TSL.materialNormal;
var materialOpacity = TSL.materialOpacity;
var materialPointSize = TSL.materialPointSize;
var materialReference = TSL.materialReference;
var materialReflectivity = TSL.materialReflectivity;
var materialRefractionRatio = TSL.materialRefractionRatio;
var materialRotation = TSL.materialRotation;
var materialRoughness = TSL.materialRoughness;
var materialSheen = TSL.materialSheen;
var materialSheenRoughness = TSL.materialSheenRoughness;
var materialShininess = TSL.materialShininess;
var materialSpecular = TSL.materialSpecular;
var materialSpecularColor = TSL.materialSpecularColor;
var materialSpecularIntensity = TSL.materialSpecularIntensity;
var materialSpecularStrength = TSL.materialSpecularStrength;
var materialThickness = TSL.materialThickness;
var materialTransmission = TSL.materialTransmission;
var max = TSL.max;
var maxMipLevel = TSL.maxMipLevel;
var metalness = TSL.metalness;
var min = TSL.min;
var mix = TSL.mix;
var mixElement = TSL.mixElement;
var mod = TSL.mod;
var modInt = TSL.modInt;
var modelDirection = TSL.modelDirection;
var modelNormalMatrix = TSL.modelNormalMatrix;
var modelPosition = TSL.modelPosition;
var modelRadius = TSL.modelRadius;
var modelScale = TSL.modelScale;
var modelViewMatrix = TSL.modelViewMatrix;
var modelViewPosition = TSL.modelViewPosition;
var modelViewProjection = TSL.modelViewProjection;
var modelWorldMatrix = TSL.modelWorldMatrix;
var modelWorldMatrixInverse = TSL.modelWorldMatrixInverse;
var morphReference = TSL.morphReference;
var mrt = TSL.mrt;
var mul = TSL.mul;
var mx_aastep = TSL.mx_aastep;
var mx_cell_noise_float = TSL.mx_cell_noise_float;
var mx_contrast = TSL.mx_contrast;
var mx_fractal_noise_float = TSL.mx_fractal_noise_float;
var mx_fractal_noise_vec2 = TSL.mx_fractal_noise_vec2;
var mx_fractal_noise_vec3 = TSL.mx_fractal_noise_vec3;
var mx_fractal_noise_vec4 = TSL.mx_fractal_noise_vec4;
var mx_hsvtorgb = TSL.mx_hsvtorgb;
var mx_noise_float = TSL.mx_noise_float;
var mx_noise_vec3 = TSL.mx_noise_vec3;
var mx_noise_vec4 = TSL.mx_noise_vec4;
var mx_ramplr = TSL.mx_ramplr;
var mx_ramptb = TSL.mx_ramptb;
var mx_rgbtohsv = TSL.mx_rgbtohsv;
var mx_safepower = TSL.mx_safepower;
var mx_splitlr = TSL.mx_splitlr;
var mx_splittb = TSL.mx_splittb;
var mx_srgb_texture_to_lin_rec709 = TSL.mx_srgb_texture_to_lin_rec709;
var mx_transform_uv = TSL.mx_transform_uv;
var mx_worley_noise_float = TSL.mx_worley_noise_float;
var mx_worley_noise_vec2 = TSL.mx_worley_noise_vec2;
var mx_worley_noise_vec3 = TSL.mx_worley_noise_vec3;
var negate = TSL.negate;
var neutralToneMapping = TSL.neutralToneMapping;
var nodeArray = TSL.nodeArray;
var nodeImmutable = TSL.nodeImmutable;
var nodeObject = TSL.nodeObject;
var nodeObjects = TSL.nodeObjects;
var nodeProxy = TSL.nodeProxy;
var normalFlat = TSL.normalFlat;
var normalGeometry = TSL.normalGeometry;
var normalLocal = TSL.normalLocal;
var normalMap = TSL.normalMap;
var normalView = TSL.normalView;
var normalViewGeometry = TSL.normalViewGeometry;
var normalWorld = TSL.normalWorld;
var normalWorldGeometry = TSL.normalWorldGeometry;
var normalize = TSL.normalize;
var not = TSL.not;
var notEqual = TSL.notEqual;
var numWorkgroups = TSL.numWorkgroups;
var objectDirection = TSL.objectDirection;
var objectGroup = TSL.objectGroup;
var objectPosition = TSL.objectPosition;
var objectRadius = TSL.objectRadius;
var objectScale = TSL.objectScale;
var objectViewPosition = TSL.objectViewPosition;
var objectWorldMatrix = TSL.objectWorldMatrix;
var oneMinus = TSL.oneMinus;
var or = TSL.or;
var orthographicDepthToViewZ = TSL.orthographicDepthToViewZ;
var oscSawtooth = TSL.oscSawtooth;
var oscSine = TSL.oscSine;
var oscSquare = TSL.oscSquare;
var oscTriangle = TSL.oscTriangle;
var output = TSL.output;
var outputStruct = TSL.outputStruct;
var overlay = TSL.overlay;
var overloadingFn = TSL.overloadingFn;
var parabola = TSL.parabola;
var parallaxDirection = TSL.parallaxDirection;
var parallaxUV = TSL.parallaxUV;
var parameter = TSL.parameter;
var pass = TSL.pass;
var passTexture = TSL.passTexture;
var pcurve = TSL.pcurve;
var perspectiveDepthToViewZ = TSL.perspectiveDepthToViewZ;
var pmremTexture = TSL.pmremTexture;
var pointUV = TSL.pointUV;
var pointWidth = TSL.pointWidth;
var positionGeometry = TSL.positionGeometry;
var positionLocal = TSL.positionLocal;
var positionPrevious = TSL.positionPrevious;
var positionView = TSL.positionView;
var positionViewDirection = TSL.positionViewDirection;
var positionWorld = TSL.positionWorld;
var positionWorldDirection = TSL.positionWorldDirection;
var posterize = TSL.posterize;
var pow = TSL.pow;
var pow2 = TSL.pow2;
var pow3 = TSL.pow3;
var pow4 = TSL.pow4;
var premultiplyAlpha = TSL.premultiplyAlpha;
var property = TSL.property;
var radians = TSL.radians;
var rand = TSL.rand;
var range = TSL.range;
var rangeFog = TSL.rangeFog;
var rangeFogFactor = TSL.rangeFogFactor;
var reciprocal = TSL.reciprocal;
var lightProjectionUV = TSL.lightProjectionUV;
var reference = TSL.reference;
var referenceBuffer = TSL.referenceBuffer;
var reflect = TSL.reflect;
var reflectVector = TSL.reflectVector;
var reflectView = TSL.reflectView;
var reflector = TSL.reflector;
var refract = TSL.refract;
var refractVector = TSL.refractVector;
var refractView = TSL.refractView;
var reinhardToneMapping = TSL.reinhardToneMapping;
var remainder = TSL.remainder;
var remap = TSL.remap;
var remapClamp = TSL.remapClamp;
var renderGroup = TSL.renderGroup;
var renderOutput = TSL.renderOutput;
var rendererReference = TSL.rendererReference;
var rotate = TSL.rotate;
var rotateUV = TSL.rotateUV;
var roughness = TSL.roughness;
var round = TSL.round;
var rtt = TSL.rtt;
var sRGBTransferEOTF = TSL.sRGBTransferEOTF;
var sRGBTransferOETF = TSL.sRGBTransferOETF;
var sample = TSL.sample;
var sampler = TSL.sampler;
var samplerComparison = TSL.samplerComparison;
var saturate = TSL.saturate;
var saturation = TSL.saturation;
var screen = TSL.screen;
var screenCoordinate = TSL.screenCoordinate;
var screenSize = TSL.screenSize;
var screenUV = TSL.screenUV;
var scriptable = TSL.scriptable;
var scriptableValue = TSL.scriptableValue;
var select = TSL.select;
var setCurrentStack = TSL.setCurrentStack;
var shaderStages = TSL.shaderStages;
var shadow = TSL.shadow;
var pointShadow = TSL.pointShadow;
var shadowPositionWorld = TSL.shadowPositionWorld;
var sharedUniformGroup = TSL.sharedUniformGroup;
var shapeCircle = TSL.shapeCircle;
var sheen = TSL.sheen;
var sheenRoughness = TSL.sheenRoughness;
var shiftLeft = TSL.shiftLeft;
var shiftRight = TSL.shiftRight;
var shininess = TSL.shininess;
var sign = TSL.sign;
var sin = TSL.sin;
var sinc = TSL.sinc;
var skinning = TSL.skinning;
var smoothstep = TSL.smoothstep;
var smoothstepElement = TSL.smoothstepElement;
var specularColor = TSL.specularColor;
var specularF90 = TSL.specularF90;
var spherizeUV = TSL.spherizeUV;
var split = TSL.split;
var spritesheetUV = TSL.spritesheetUV;
var sqrt = TSL.sqrt;
var stack = TSL.stack;
var step = TSL.step;
var storage = TSL.storage;
var storageBarrier = TSL.storageBarrier;
var storageObject = TSL.storageObject;
var storageTexture = TSL.storageTexture;
var string = TSL.string;
var struct = TSL.struct;
var sub = TSL.sub;
var subBuild = TSL.subBuild;
var subgroupIndex = TSL.subgroupIndex;
var subgroupSize = TSL.subgroupSize;
var tan = TSL.tan;
var tangentGeometry = TSL.tangentGeometry;
var tangentLocal = TSL.tangentLocal;
var tangentView = TSL.tangentView;
var tangentWorld = TSL.tangentWorld;
var temp = TSL.temp;
var texture = TSL.texture;
var texture3D = TSL.texture3D;
var textureBarrier = TSL.textureBarrier;
var textureBicubic = TSL.textureBicubic;
var textureBicubicLevel = TSL.textureBicubicLevel;
var textureCubeUV = TSL.textureCubeUV;
var textureLoad = TSL.textureLoad;
var textureSize = TSL.textureSize;
var textureStore = TSL.textureStore;
var thickness = TSL.thickness;
var time = TSL.time;
var timerDelta = TSL.timerDelta;
var timerGlobal = TSL.timerGlobal;
var timerLocal = TSL.timerLocal;
var toneMapping = TSL.toneMapping;
var toneMappingExposure = TSL.toneMappingExposure;
var toonOutlinePass = TSL.toonOutlinePass;
var transformDirection = TSL.transformDirection;
var transformNormal = TSL.transformNormal;
var transformNormalToView = TSL.transformNormalToView;
var transformedClearcoatNormalView = TSL.transformedClearcoatNormalView;
var transformedNormalView = TSL.transformedNormalView;
var transformedNormalWorld = TSL.transformedNormalWorld;
var transmission = TSL.transmission;
var transpose = TSL.transpose;
var triNoise3D = TSL.triNoise3D;
var triplanarTexture = TSL.triplanarTexture;
var triplanarTextures = TSL.triplanarTextures;
var trunc = TSL.trunc;
var tslFn = TSL.tslFn;
var uint = TSL.uint;
var uniform = TSL.uniform;
var uniformCubeTexture = TSL.uniformCubeTexture;
var uniformArray = TSL.uniformArray;
var uniformGroup = TSL.uniformGroup;
var uniformTexture = TSL.uniformTexture;
var uniforms = TSL.uniforms;
var unpremultiplyAlpha = TSL.unpremultiplyAlpha;
var userData = TSL.userData;
var uv = TSL.uv;
var uvec2 = TSL.uvec2;
var uvec3 = TSL.uvec3;
var uvec4 = TSL.uvec4;
var Var = TSL.Var;
var varying = TSL.varying;
var varyingProperty = TSL.varyingProperty;
var vec2 = TSL.vec2;
var vec3 = TSL.vec3;
var vec4 = TSL.vec4;
var vectorComponents = TSL.vectorComponents;
var velocity = TSL.velocity;
var vertexColor = TSL.vertexColor;
var vertexIndex = TSL.vertexIndex;
var vibrance = TSL.vibrance;
var viewZToLogarithmicDepth = TSL.viewZToLogarithmicDepth;
var viewZToOrthographicDepth = TSL.viewZToOrthographicDepth;
var viewZToPerspectiveDepth = TSL.viewZToPerspectiveDepth;
var viewport = TSL.viewport;
var viewportBottomLeft = TSL.viewportBottomLeft;
var viewportCoordinate = TSL.viewportCoordinate;
var viewportDepthTexture = TSL.viewportDepthTexture;
var viewportLinearDepth = TSL.viewportLinearDepth;
var viewportMipTexture = TSL.viewportMipTexture;
var viewportResolution = TSL.viewportResolution;
var viewportSafeUV = TSL.viewportSafeUV;
var viewportSharedTexture = TSL.viewportSharedTexture;
var viewportSize = TSL.viewportSize;
var viewportTexture = TSL.viewportTexture;
var viewportTopLeft = TSL.viewportTopLeft;
var viewportUV = TSL.viewportUV;
var wgsl = TSL.wgsl;
var wgslFn = TSL.wgslFn;
var workgroupArray = TSL.workgroupArray;
var workgroupBarrier = TSL.workgroupBarrier;
var workgroupId = TSL.workgroupId;
var workingToColorSpace = TSL.workingToColorSpace;
var xor = TSL.xor;

// node_modules/@pixiv/three-vrm/lib/nodes/index.module.js
var threeRevision = parseInt(REVISION, 10);
if (threeRevision < 167) {
  console.warn(
    `MToonNodeMaterial requires Three.js r167 or higher (You are using r${threeRevision}). This would not work correctly.`
  );
}
var refColor = materialReference("color", "color");
var refMap = materialReference("map", "texture");
var refNormalMap = materialReference("normalMap", "texture");
var refNormalScale = materialReference("normalScale", "vec2");
var refEmissive = materialReference("emissive", "color");
var refEmissiveIntensity = materialReference("emissiveIntensity", "float");
var refEmissiveMap = materialReference("emissiveMap", "texture");
var refShadeColorFactor = materialReference("shadeColorFactor", "color");
var refShadingShiftFactor = materialReference("shadingShiftFactor", "float");
var refShadeMultiplyTexture = materialReference("shadeMultiplyTexture", "texture");
var refShadeMultiplyTextureScale = materialReference("shadeMultiplyTextureScale", "float");
var refShadingToonyFactor = materialReference("shadingToonyFactor", "float");
var refRimLightingMixFactor = materialReference("rimLightingMixFactor", "float");
var refRimMultiplyTexture = materialReference("rimMultiplyTexture", "texture");
var refMatcapFactor = materialReference("matcapFactor", "color");
var refMatcapTexture = materialReference("matcapTexture", "texture");
var refParametricRimColorFactor = materialReference("parametricRimColorFactor", "color");
var refParametricRimLiftFactor = materialReference("parametricRimLiftFactor", "float");
var refParametricRimFresnelPowerFactor = materialReference("parametricRimFresnelPowerFactor", "float");
var refOutlineWidthMultiplyTexture = materialReference("outlineWidthMultiplyTexture", "texture");
var refOutlineWidthFactor = materialReference("outlineWidthFactor", "float");
var refOutlineColorFactor = materialReference("outlineColorFactor", "color");
var refOutlineLightingMixFactor = materialReference("outlineLightingMixFactor", "float");
var refUVAnimationMaskTexture = materialReference("uvAnimationMaskTexture", "texture");
var refUVAnimationScrollXOffset = materialReference("uvAnimationScrollXOffset", "float");
var refUVAnimationScrollYOffset = materialReference("uvAnimationScrollYOffset", "float");
var refUVAnimationRotationPhase = materialReference("uvAnimationRotationPhase", "float");
var MToonAnimatedUVNode = class extends TempNode {
  constructor(hasMaskTexture) {
    super("vec2");
    this.hasMaskTexture = hasMaskTexture;
  }
  setup() {
    let uvAnimationMask = 1;
    if (this.hasMaskTexture) {
      uvAnimationMask = vec4(refUVAnimationMaskTexture).context({ getUV: () => uv() }).r;
    }
    let animatedUv = uv();
    const phase = refUVAnimationRotationPhase.mul(uvAnimationMask);
    const c = cos(phase);
    const s = sin(phase);
    animatedUv = animatedUv.sub(vec2(0.5, 0.5));
    animatedUv = animatedUv.mul(mat2(c, s, s.negate(), c));
    animatedUv = animatedUv.add(vec2(0.5, 0.5));
    const scroll = vec2(refUVAnimationScrollXOffset, refUVAnimationScrollYOffset).mul(uvAnimationMask);
    animatedUv = animatedUv.add(scroll);
    return animatedUv.toVar("AnimatedUV");
  }
};
var shadeColor = nodeImmutable(PropertyNode, "vec3").toVar("ShadeColor");
var shadingShift = nodeImmutable(PropertyNode, "float").toVar("ShadingShift");
var shadingToony = nodeImmutable(PropertyNode, "float").toVar("ShadingToony");
var rimLightingMix = nodeImmutable(PropertyNode, "float").toVar("RimLightingMix");
var rimMultiply = nodeImmutable(PropertyNode, "vec3").toVar("RimMultiply");
var matcap = nodeImmutable(PropertyNode, "vec3").toVar("matcap");
var parametricRim = nodeImmutable(PropertyNode, "vec3").toVar("ParametricRim");
var FnCompat = (jsFunc) => {
  const threeRevision2 = parseInt(REVISION, 10);
  if (threeRevision2 >= 168) {
    return Fn(jsFunc);
  } else {
    return (void 0)(jsFunc);
  }
};
var linearstep = FnCompat(
  ({
    a,
    b,
    t
  }) => {
    const top = t.sub(a);
    const bottom = b.sub(a);
    return top.div(bottom).clamp();
  }
);
var getShading = FnCompat(({ dotNL }) => {
  const shadow2 = 1;
  const feather = float(1).sub(shadingToony);
  let shading = dotNL.add(shadingShift);
  shading = linearstep({
    a: feather.negate(),
    b: feather,
    t: shading
  });
  shading = shading.mul(shadow2);
  return shading;
});
var getDiffuse = FnCompat(
  ({ shading, lightColor }) => {
    const feathered = mix(shadeColor, diffuseColor, shading);
    const col = lightColor.mul(BRDF_Lambert({ diffuseColor: feathered }));
    return col;
  }
);
var MToonLightingModel = class extends LightingModel {
  constructor() {
    super();
  }
  direct({
    lightDirection,
    lightColor,
    reflectedLight
  }) {
    const dotNL = transformedNormalView.dot(lightDirection).clamp(-1, 1);
    const shading = getShading({
      dotNL
    });
    reflectedLight.directDiffuse.addAssign(
      getDiffuse({
        shading,
        lightColor
      })
    );
    reflectedLight.directSpecular.addAssign(
      parametricRim.add(matcap).mul(rimMultiply).mul(mix(vec3(0), BRDF_Lambert({ diffuseColor: lightColor }), rimLightingMix))
    );
  }
  // COMPAT: pre-r174
  // `builderOrContext`: `THREE.NodeBuilder` in >= r174, `LightingModelIndirectInput` (`LightingContext`) otherwise
  indirect(builderOrContext) {
    const context2 = "context" in builderOrContext ? builderOrContext.context : builderOrContext;
    this.indirectDiffuse(context2);
    this.indirectSpecular(context2);
  }
  indirectDiffuse(context2) {
    const { irradiance, reflectedLight } = context2;
    reflectedLight.indirectDiffuse.addAssign(
      irradiance.mul(BRDF_Lambert({ diffuseColor }))
    );
  }
  indirectSpecular(context2) {
    const { reflectedLight } = context2;
    reflectedLight.indirectSpecular.addAssign(
      parametricRim.add(matcap).mul(rimMultiply).mul(mix(vec3(1), vec3(0), rimLightingMix))
    );
  }
};
var MToonMaterialOutlineWidthMode = {
  None: "none",
  WorldCoordinates: "worldCoordinates",
  ScreenCoordinates: "screenCoordinates"
};
var mtoonParametricRim = FnCompat(
  ({
    parametricRimLift,
    parametricRimFresnelPower,
    parametricRimColor
  }) => {
    const viewDir = modelViewPosition.normalize();
    const dotNV = transformedNormalView.dot(viewDir.negate());
    const rim = float(1).sub(dotNV).add(parametricRimLift).clamp().pow(parametricRimFresnelPower);
    return rim.mul(parametricRimColor);
  }
);
var MToonNodeMaterial = class extends NodeMaterial {
  customProgramCacheKey() {
    let cacheKey = super.customProgramCacheKey();
    cacheKey += `isOutline:${this.isOutline},`;
    return cacheKey;
  }
  /**
   * Readonly boolean that indicates this is a {@link MToonNodeMaterial}.
   */
  get isMToonNodeMaterial() {
    return true;
  }
  constructor(parameters = {}) {
    super();
    if (parameters.transparentWithZWrite) {
      parameters.depthWrite = true;
    }
    delete parameters.transparentWithZWrite;
    delete parameters.giEqualizationFactor;
    delete parameters.v0CompatShade;
    delete parameters.debugMode;
    this.emissiveNode = null;
    this.lights = true;
    this.color = new Color(1, 1, 1);
    this.map = null;
    this.emissive = new Color(0, 0, 0);
    this.emissiveIntensity = 1;
    this.emissiveMap = null;
    this.normalMap = null;
    this.normalScale = new Vector2(1, 1);
    this.shadeColorFactor = new Color(0, 0, 0);
    this.shadeMultiplyTexture = null;
    this.shadingShiftFactor = 0;
    this.shadingShiftTexture = null;
    this.shadingShiftTextureScale = 1;
    this.shadingToonyFactor = 0.9;
    this.rimLightingMixFactor = 1;
    this.rimMultiplyTexture = null;
    this.matcapFactor = new Color(1, 1, 1);
    this.matcapTexture = null;
    this.parametricRimColorFactor = new Color(0, 0, 0);
    this.parametricRimLiftFactor = 0;
    this.parametricRimFresnelPowerFactor = 5;
    this.outlineWidthMode = MToonMaterialOutlineWidthMode.None;
    this.outlineWidthMultiplyTexture = null;
    this.outlineWidthFactor = 0;
    this.outlineColorFactor = new Color(0, 0, 0);
    this.outlineLightingMixFactor = 1;
    this.uvAnimationScrollXSpeedFactor = 0;
    this.uvAnimationScrollYSpeedFactor = 0;
    this.uvAnimationRotationSpeedFactor = 0;
    this.uvAnimationMaskTexture = null;
    this.shadeColorNode = null;
    this.shadingShiftNode = null;
    this.shadingToonyNode = null;
    this.rimLightingMixNode = null;
    this.rimMultiplyNode = null;
    this.matcapNode = null;
    this.parametricRimColorNode = null;
    this.parametricRimLiftNode = null;
    this.parametricRimFresnelPowerNode = null;
    this.uvAnimationScrollXOffset = 0;
    this.uvAnimationScrollYOffset = 0;
    this.uvAnimationRotationPhase = 0;
    this.isOutline = false;
    this._animatedUVNode = null;
    this.setValues(parameters);
  }
  setupLightingModel() {
    return new MToonLightingModel();
  }
  setup(builder) {
    var _a;
    this._animatedUVNode = new MToonAnimatedUVNode(
      (_a = this.uvAnimationMaskTexture && this.uvAnimationMaskTexture.isTexture === true) != null ? _a : false
    );
    super.setup(builder);
  }
  setupDiffuseColor(builder) {
    let tempColorNode = null;
    if (this.colorNode == null) {
      tempColorNode = refColor;
      if (this.map && this.map.isTexture === true) {
        const map = refMap.context({ getUV: () => this._animatedUVNode });
        tempColorNode = tempColorNode.mul(map);
      }
      this.colorNode = tempColorNode;
    }
    if (this.vertexColors === true && builder.geometry.hasAttribute("color")) {
      console.warn(
        "MToonNodeMaterial: MToon ignores vertex colors. Consider using a model without vertex colors instead."
      );
      this.vertexColors = false;
    }
    super.setupDiffuseColor(builder);
    if (parseInt(REVISION, 10) < 166) {
      if (this.transparent === false && this.blending === NormalBlending && this.alphaToCoverage === false) {
        diffuseColor.a.assign(1);
      }
    }
    if (this.colorNode === tempColorNode) {
      this.colorNode = null;
    }
  }
  setupVariants() {
    shadeColor.assign(this._setupShadeColorNode());
    shadingShift.assign(this._setupShadingShiftNode());
    shadingToony.assign(this._setupShadingToonyNode());
    rimLightingMix.assign(this._setupRimLightingMixNode());
    rimMultiply.assign(this._setupRimMultiplyNode());
    matcap.assign(this._setupMatcapNode());
    parametricRim.assign(this._setupParametricRimNode());
  }
  setupNormal(builder) {
    const tempNormalNode = this.normalNode;
    if (this.normalNode == null) {
      this.normalNode = materialNormal;
      if (this.normalMap && this.normalMap.isTexture === true) {
        const map = refNormalMap.context({ getUV: () => this._animatedUVNode });
        this.normalNode = normalMap(map, refNormalScale);
      }
      if (this.isOutline) {
        this.normalNode = this.normalNode.negate();
      }
    }
    const threeRevision2 = parseInt(REVISION, 10);
    if (threeRevision2 >= 168) {
      const ret = this.normalNode;
      this.normalNode = tempNormalNode;
      return ret;
    } else {
      super.setupNormal(builder);
      this.normalNode = tempNormalNode;
      return void 0;
    }
  }
  setupLighting(builder) {
    let tempEmissiveNode = null;
    if (this.emissiveNode == null) {
      tempEmissiveNode = refEmissive.mul(refEmissiveIntensity);
      if (this.emissiveMap && this.emissiveMap.isTexture === true) {
        const map = refEmissiveMap.context({ getUV: () => this._animatedUVNode });
        tempEmissiveNode = tempEmissiveNode.mul(map);
      }
      this.emissiveNode = tempEmissiveNode;
    }
    const ret = super.setupLighting(builder);
    if (this.emissiveNode === tempEmissiveNode) {
      this.emissiveNode = null;
    }
    return ret;
  }
  setupOutput(builder, outputNode) {
    if (this.isOutline && this.outlineWidthMode !== MToonMaterialOutlineWidthMode.None) {
      outputNode = vec4(
        mix(refOutlineColorFactor, outputNode.xyz.mul(refOutlineColorFactor), refOutlineLightingMixFactor),
        outputNode.w
      );
    }
    return super.setupOutput(builder, outputNode);
  }
  setupPosition(builder) {
    var _a, _b;
    const tempPositionNode = this.positionNode;
    if (this.isOutline && this.outlineWidthMode !== MToonMaterialOutlineWidthMode.None) {
      (_a = this.positionNode) != null ? _a : this.positionNode = positionLocal;
      const normalLocalNormalized = normalLocal.normalize();
      let width = refOutlineWidthFactor;
      if (this.outlineWidthMultiplyTexture && this.outlineWidthMultiplyTexture.isTexture === true) {
        const map = refOutlineWidthMultiplyTexture.context({ getUV: () => this._animatedUVNode });
        width = width.mul(map);
      }
      const worldNormalLength = length(modelNormalMatrix.mul(normalLocalNormalized));
      const outlineOffset = width.mul(worldNormalLength).mul(normalLocalNormalized);
      if (this.outlineWidthMode === MToonMaterialOutlineWidthMode.WorldCoordinates) {
        this.positionNode = this.positionNode.add(outlineOffset);
      } else if (this.outlineWidthMode === MToonMaterialOutlineWidthMode.ScreenCoordinates) {
        const clipScale = cameraProjectionMatrix.element(1).element(1);
        const tempPositionView = modelViewMatrix.mul(positionLocal);
        this.positionNode = this.positionNode.add(
          outlineOffset.div(clipScale).mul(tempPositionView.z.negate())
        );
      }
      (_b = this.positionNode) != null ? _b : this.positionNode = positionLocal;
    }
    const ret = super.setupPosition(builder);
    ret.z.add(ret.w.mul(1e-6));
    this.positionNode = tempPositionNode;
    return ret;
  }
  copy(source) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r, _s;
    this.color.copy(source.color);
    this.map = (_a = source.map) != null ? _a : null;
    this.emissive.copy(source.emissive);
    this.emissiveIntensity = source.emissiveIntensity;
    this.emissiveMap = (_b = source.emissiveMap) != null ? _b : null;
    this.normalMap = (_c = source.normalMap) != null ? _c : null;
    this.normalScale.copy(source.normalScale);
    this.shadeColorFactor.copy(source.shadeColorFactor);
    this.shadeMultiplyTexture = (_d = source.shadeMultiplyTexture) != null ? _d : null;
    this.shadingShiftFactor = source.shadingShiftFactor;
    this.shadingShiftTexture = (_e = source.shadingShiftTexture) != null ? _e : null;
    this.shadingShiftTextureScale = source.shadingShiftTextureScale;
    this.shadingToonyFactor = source.shadingToonyFactor;
    this.rimLightingMixFactor = source.rimLightingMixFactor;
    this.rimMultiplyTexture = (_f = source.rimMultiplyTexture) != null ? _f : null;
    this.matcapFactor.copy(source.matcapFactor);
    this.matcapTexture = (_g = source.matcapTexture) != null ? _g : null;
    this.parametricRimColorFactor.copy(source.parametricRimColorFactor);
    this.parametricRimLiftFactor = source.parametricRimLiftFactor;
    this.parametricRimFresnelPowerFactor = source.parametricRimFresnelPowerFactor;
    this.outlineWidthMode = source.outlineWidthMode;
    this.outlineWidthMultiplyTexture = (_h = source.outlineWidthMultiplyTexture) != null ? _h : null;
    this.outlineWidthFactor = source.outlineWidthFactor;
    this.outlineColorFactor.copy(source.outlineColorFactor);
    this.outlineLightingMixFactor = source.outlineLightingMixFactor;
    this.uvAnimationScrollXSpeedFactor = source.uvAnimationScrollXSpeedFactor;
    this.uvAnimationScrollYSpeedFactor = source.uvAnimationScrollYSpeedFactor;
    this.uvAnimationRotationSpeedFactor = source.uvAnimationRotationSpeedFactor;
    this.uvAnimationMaskTexture = (_i = source.uvAnimationMaskTexture) != null ? _i : null;
    this.shadeColorNode = (_j = source.shadeColorNode) != null ? _j : null;
    this.shadingShiftNode = (_k = source.shadingShiftNode) != null ? _k : null;
    this.shadingToonyNode = (_l = source.shadingToonyNode) != null ? _l : null;
    this.rimLightingMixNode = (_m = source.rimLightingMixNode) != null ? _m : null;
    this.rimMultiplyNode = (_n = source.rimMultiplyNode) != null ? _n : null;
    this.matcapNode = (_o = source.matcapNode) != null ? _o : null;
    this.parametricRimColorNode = (_p = source.parametricRimColorNode) != null ? _p : null;
    this.parametricRimLiftNode = (_q = source.parametricRimLiftNode) != null ? _q : null;
    this.parametricRimFresnelPowerNode = (_r = source.parametricRimFresnelPowerNode) != null ? _r : null;
    this.isOutline = (_s = source.isOutline) != null ? _s : null;
    return super.copy(source);
  }
  update(delta) {
    this.uvAnimationScrollXOffset += delta * this.uvAnimationScrollXSpeedFactor;
    this.uvAnimationScrollYOffset += delta * this.uvAnimationScrollYSpeedFactor;
    this.uvAnimationRotationPhase += delta * this.uvAnimationRotationSpeedFactor;
  }
  _setupShadeColorNode() {
    if (this.shadeColorNode != null) {
      return vec3(this.shadeColorNode);
    }
    let shadeColorNode = refShadeColorFactor;
    if (this.shadeMultiplyTexture && this.shadeMultiplyTexture.isTexture === true) {
      const map = refShadeMultiplyTexture.context({ getUV: () => this._animatedUVNode });
      shadeColorNode = shadeColorNode.mul(map);
    }
    return shadeColorNode;
  }
  _setupShadingShiftNode() {
    if (this.shadingShiftNode != null) {
      return float(this.shadingShiftNode);
    }
    let shadingShiftNode = refShadingShiftFactor;
    if (this.shadingShiftTexture && this.shadingShiftTexture.isTexture === true) {
      const map = refShadeMultiplyTexture.context({ getUV: () => this._animatedUVNode });
      shadingShiftNode = shadingShiftNode.add(map.mul(refShadeMultiplyTextureScale));
    }
    return shadingShiftNode;
  }
  _setupShadingToonyNode() {
    if (this.shadingToonyNode != null) {
      return float(this.shadingToonyNode);
    }
    return refShadingToonyFactor;
  }
  _setupRimLightingMixNode() {
    if (this.rimLightingMixNode != null) {
      return float(this.rimLightingMixNode);
    }
    return refRimLightingMixFactor;
  }
  _setupRimMultiplyNode() {
    if (this.rimMultiplyNode != null) {
      return vec3(this.rimMultiplyNode);
    }
    if (this.rimMultiplyTexture && this.rimMultiplyTexture.isTexture === true) {
      const map = refRimMultiplyTexture.context({ getUV: () => this._animatedUVNode });
      return map;
    }
    return vec3(1);
  }
  _setupMatcapNode() {
    if (this.matcapNode != null) {
      return vec3(this.matcapNode);
    }
    if (this.matcapTexture && this.matcapTexture.isTexture === true) {
      const map = refMatcapTexture.context({ getUV: () => matcapUV.mul(1, -1).add(0, 1) });
      return map.mul(refMatcapFactor);
    }
    return vec3(0);
  }
  _setupParametricRimNode() {
    const parametricRimColor = this.parametricRimColorNode != null ? vec3(this.parametricRimColorNode) : refParametricRimColorFactor;
    const parametricRimLift = this.parametricRimLiftNode != null ? float(this.parametricRimLiftNode) : refParametricRimLiftFactor;
    const parametricRimFresnelPower = this.parametricRimFresnelPowerNode != null ? float(this.parametricRimFresnelPowerNode) : refParametricRimFresnelPowerFactor;
    return mtoonParametricRim({
      parametricRimLift,
      parametricRimFresnelPower,
      parametricRimColor
    });
  }
};
export {
  MToonAnimatedUVNode,
  MToonLightingModel,
  MToonNodeMaterial
};
/*! Bundled license information:

three/build/three.tsl.js:
  (**
   * @license
   * Copyright 2010-2025 Three.js Authors
   * SPDX-License-Identifier: MIT
   *)

@pixiv/three-vrm/lib/nodes/index.module.js:
  (*!
   * @pixiv/three-vrm v3.4.2
   * VRM file loader for three.js.
   *
   * Copyright (c) 2019-2025 pixiv Inc.
   * @pixiv/three-vrm is distributed under MIT License
   * https://github.com/pixiv/three-vrm/blob/release/LICENSE
   *)

@pixiv/three-vrm/lib/nodes/index.module.js:
  (*!
   * @pixiv/three-vrm-materials-mtoon v3.4.2
   * MToon (toon material) module for @pixiv/three-vrm
   *
   * Copyright (c) 2019-2025 pixiv Inc.
   * @pixiv/three-vrm-materials-mtoon is distributed under MIT License
   * https://github.com/pixiv/three-vrm/blob/release/LICENSE
   *)
*/
//# sourceMappingURL=@pixiv_three-vrm_nodes.js.map
